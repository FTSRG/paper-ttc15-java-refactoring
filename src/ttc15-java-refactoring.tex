\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TTC 2015}

\input{ttc15-commands.tex}
\usepackage{enumitem}

\newcommand{\pum}{\ttcsf{Pull Up Method}\@\xspace}
\newcommand{\cscz}{\ttcsf{Create Superclass}\@\xspace}

% metadata
\title{Java Refactoring Case: a \viatra Solution\thanks{This work was partially supported by the MONDO (EU ICT-611125) project.}}
\author{D\'{a}niel Stein \qquad G\'{a}bor Sz\'{a}rnyas \qquad Istv\'{a}n R\'{a}th
\institute{Budapest University of Technology and Economics\\
Department of Measurement and Information Systems\\
H-1117 Magyar tud\'{o}sok krt. 2, Budapest, Hungary}
\email{daniel.stein@inf.mit.bme.hu, \{szarnyas, rath\}@mit.bme.hu}
}
\def\titlerunning{Java Refactoring Case: a VIATRA Solution}
\def\authorrunning{D. Stein et al.}

\begin{document}
\maketitle

\begin{abstract}
This paper presents a solution for the Java Refactoring Case of the 2015 Transformation Tool Contest. The solution utilises \jdt for creating the program graph; while \eiq, \viatra and the \xtend programming language are used for defining and performing the model transformations.
\end{abstract}

\section{Introduction}

This paper describes a solution for the extended version of the TTC 2015 Java Refactoring Case. The source code of the solution is available as an open-source project.\footnote{\url{https://github.com/FTSRG/java-refactoring-ttc-viatra}} There is also a SHARE image available.\footnote{\url{http://is.ieis.tue.nl/staff/pvgorp/share/?page=ConfigureNewSession&vdi=ArchLinux64_java-refactoring-viatra.vdi}}

The use of automated model transformations is a key factor in modern model-driven system engineering. Model transformations allow the users to query, derive and manipulate large industrial models, including models based on existing systems, \eg source code models created with reverse engineering techniques. Since such transformations are frequently integrated to modeling environments, they need to feature both high performance and a concise programming interface to support software engineers. \eiq and \viatra aim to provide an expressive query language and a carefully designed API for defining model queries and transformations.

\section{Case Description}

Refactoring operations are often used in software engineering to improve the readability, maintainability of existing source code without altering the behaviour of the software. The goal of the Java Refactoring Case~\cite{ttc-refactoring-case} is to use model transformation tools to refactor Java source code. We decided to solve the extended version of the case. For this, the solution has to tackle the following challenges:

\begin{enumerate}[noitemsep]
\item Transforming the \emph{Java source code} to a \emph{program graph} (PG).
\item Performing the refactoring transformation on the program graph.
\item Synchronising the source code and the program graph.
\end{enumerate}

The source code is defined in a restricted sub-language of Java 1.4. The EMF metamodel of the PG is provided in the case description. The case considers two basic refactoring operations:

\begin{itemize}[noitemsep]
\item \pum
\item \cscz
\end{itemize}

The solution is tested in an automated test framework, ARTE (Automated Refactoring Test Environment). ARTE runs a set of test cases, each consisting of a source code projects and refactoring operations to check the correctness and the performance of the solution.

\section{Technologies}

Solving the case requires the integration of a model transformation tool and a Java source code parser. In this section, we introduce the technologies used in our solution.

\subsection{\eiq}

The objective of the \eiq~\cite{models2010, eiq-homepage} framework is to provide a declarative way to define queries over EMF models. \eiq extended the pattern language of \viatratwo with new features (including transitive closure, role navigation, match count) and tailored it to EMF models~\cite{iqpl}. While \eiq is developed with a focus on \emph{incremental query evaluation}, the latest version also provides a \emph{local search-based query evaluation} algorithm.

\subsection{\viatra}

The \viatra framework supports the development of model transformations with specific focus on event-driven, reactive transformations~\cite{viatra}. Building upon the incremental query support of \eiq, \viatra offers a language to define transformations and a reactive transformation engine to execute certain transformations upon changes in the underlying model. The \viatra project provides:

\begin{itemize}[noitemsep]
	\item An internal DSL over the \xtend~\cite{Xtend} language to specify both batch and event-driven, reactive transformations.
	\item A complex event-processing engine over EMF models to specify reactions upon detecting complex sequences of events.
	\item A rule-based design space exploration framework to explore design candidates as models satisfying multiple criteria.
	\item A model obfuscator to remove sensitive information from a confidential model, \eg for creating bug reports.
\end{itemize}

The current \viatra{} project is a full rewrite of the previous \viatratwo{} framework, now with full compatibility and support for EMF models. The history of the \viatra{} family is described in~\cite{viatra-history}.

\subsection{Java Development Tools}

The solution requires a technology to parse the Java code into a program graph model and serialize the modified graph model back to source code. While the case description mentions the JaMoPP~\cite{JaMoPP} and MoDisco~\cite{MoDisco} technologies, our solution builds on top of the Eclipse Java Development Tools (JDT)~\cite{jdt} used in the Eclipse Java IDE as we were already using JDT in other projects.

Compared to the MoDisco framework (which uses JDT internally), we found JDT to be simpler to deploy outside the Eclipse environment, \ie without defining an Eclipse workspace. Meanwhile, the JaMoPP project has almost completely been abandoned and therefore it is only capable of parsing Java 1.5 source files. While this would not pose a problem for this case, we think it is best to use an actively developed technology such as JDT which supports the latest (1.8) version of the Java language. As JDT is frequently used to parse large source code repositories, it is carefully optimised and supports lazy loading. Unlike JaMoPP and MoDisco, JDT does not produce an EMF model.

The JDT parser generates Abstract Syntax Trees (ASTs) from the provided source code files with an optional binding resolution mechanism. This way, the separate syntax trees can be connected to an Abstract Syntax Graph (ASG).



\section{Implementation}

The solution was developed partly in IntelliJ IDEA and partly in the Eclipse IDE. The projects are not tied to the any development environment and can be compiled with the Apache Maven~\cite{Maven} build automation tool. This offers a number of benefits, including easy portability and the possibility of continuous integration.

The code is written in Java~8 and Xtend~\cite{Xtend}. The queries and transformations were defined in \eiq and \viatra, respectively. For developing the Xtend code and editing the graph patterns, it is required to use the Eclipse IDE. For setting up the development environment, please refer to the readme file. 

\subsection{Workflow of the Transformation}

\ttcfig{pg}{Workflow of the transformation}{0.8}

\autoref{fig:pg} shows the workflow of the transformation. The framework receives the path to the directory containing the source files. JDT treats each source file as a \emph{compilation unit}. Each file is parsed into an AST~\ttccircled{1} (technically, the root node of the AST is the compilation unit). Using JDT's binding resolution mechanism, these ASTs are connected to an ASG.

As the JDT model does not support complex queries and traversal operations, the framework applies a visitor pattern to extract information resulting a two-pass traversal on the ASG \ttccircled{2}.

\begin{enumerate}[noitemsep]
\item For each object, the visitor creates the corresponding object(s) in the PG. The framework uses maps to store the mapping from the objects in the ASG to the objects in the PG. The visitor also registers the connection 

%ez csak részben igaz. egyrészt tárolja azt, hogy milyen jdt asg azonosítóhoz milyen pg eobject tartozik, de azt is, hogy milyen ASTNode milyen másik ASTNode-dal van x kapcsolatban és így lesznek a végén (finish()) összekötve. 
%( mivel nem tudom, hogy a visitor minden sorrendben járja be az asg astk nodejait, így string alapján csinálok tracet. 
%míg gráf esetén mindegy, hogy a hivatkozott node létezik-e már, az információ (kapcsolat) nem veszik el, itt amíg nincs eobject, nem tudnék rá hivatkozni) 

\item Using the maps populated in the previous step, the visitor creates the cross-references between the objects in the PG (\eg x and y objects).
\end{enumerate}

\subsection{Trace Model}

\ttcfig{trace-mm}{Metamodel of the trace model}{0.95}

\eiq does not support collections as pattern parameters, \eg it is not possible to define a parameterized pattern which expects a list of classes as a parameter. To overcome this limitation, we extended the program graph metamodel with a \emph{trace model} shown in~\autoref{fig:trace-mm}. The trace model defines traces for method signatures and class lists:

\begin{itemize}[noitemsep]
\item \ttcsf{MethodSignatureTrace}: A method \ttcsf{method()} expecting a \ttcsf{String} and an \ttcsf{Integer} results in the \\ \ttctt{.method(Ljava/lang/String;I)} trace.
\item \ttcsf{ClassListTrace}: A list of the \ttcsf{ChildClass1} and \ttcsf{ChildClass2} classes in the \ttcsf{example04} package results in the \ttctt{Lexample04/ChildClass1;\#Lexample04/ChildClass2;} trace.
\end{itemize}

The trace model is generated with a \viatra transformation (\autoref{lst:TraceTransformation.xtend}) using \eiq patterns (\autoref{lst:TraceQueries.eiq}).

\subsection{Refactoring}

The refactoring operations are implemented as model transformations on the JDT ASG and the PG. Each model transformation is defined in \viatra: the LHS is defined with an \eiq pattern and the RHS is defined with an imperative Xtend code. As \viatra does not support bidirectional transformations, for each transformation on the PG, we also execute the appropriate actions on the ASG to keep the two graphs in sync.

\subsection{Transforming the ASG to Source Code}

%kell ez ilyen részletesen? Amúgy ide lehet írni, hog y azért jó a JDT, mert formázást lehetőleg tartva, inkrementálisan (?) frissíti a tartalmat. Mivel nem Eclipse környezetben vagyunk, ezért a fájl mentése során nem inkrementális a fájl módosítása. 

The changes in the ASG are propagated to the source code~\ttccircled{5}. JDT is capable of incrementally maintaining each source code file on the changes in its AST.\footnote{The \textsf{CompilationUnit.rewrite()} method returns a set of text manipulation operations in the form of a \textsf{TextEdit} class.}

\section{Evaluation}

The benchmarks were conducted on SHARE, running a 64-bit Arch Linux virtual machine. The machine utilized a single core of a 2.00~GHz Xeon E5-2650 CPU and 1~GB of RAM. We used OpenJDK~8 to run ARTE framework and the solution.

\begin{table}
\centering
\footnotesize
\begin{tabular}{| l | r |}
\hline
\bf test case & \bf time [s]\\\hline\hline
\sf pub\_pum1\_1\_paper1 & 0.463 \\\hline
\sf pub\_pum1\_2 & 0.013 \\\hline
\sf pub\_pum2\_1 & 0.333 \\\hline
\sf pub\_pum3\_1 & 0.094 \\\hline
\sf pub\_csc1\_1 & 0.189 \\\hline
\sf pub\_csc1\_2 & 0.093 \\\hline
\sf hidden\_pum1\_1 & 0.063 \\\hline
\sf hidden\_pum1\_2 & 0.013 \\\hline
\sf hidden\_pum2\_1 & 0.114 \\\hline
\sf hidden\_pum2\_2 & 0.082 \\\hline
\sf hidden\_csc1\_1 & 0.081 \\\hline
\sf hidden\_csc1\_2 & 0.007 \\\hline
\sf hidden\_csc2\_1 & 0.058 \\\hline
\sf hidden\_csc3\_1a & 0.189 \\\hline
\sf hidden\_csc3\_1 & 0.179 \\\hline

\end{tabular}\caption{Execution times for the test cases.}
\label{tab:execution-times}
\end{table}

The execution times of the test cases are listed in~\autoref{tab:execution-times}. The results show that the solution is complete as all public and hidden test cases have been executed successfully. As the test cases only contained small examples, we cannot draw conclusions on the performance of the solution. However, it is worth noting that all test cases executed in less than half a second.

\section{Summary}

This paper presented a solution for the Java Refactoring case of the 2015 Transformation Tool Contest. The solution addresses both challenges (bidirectional synchrosiation and program refactoring) and both refactoring operations (pull up method, create superclass) defined in the case. The framework is flexible enough to allow the user to define new refactoring operations, \eg \ttcsf{Extract Class} or \ttcsf{Pull Up Field}.

\paragraph{Acknowledgements.} The authors would like to thank Ábel Hegedüs, Oszkár Semeráth and Zoltán Ujhelyi for providing valuable insights into \eiq and \viatra.

\bibliographystyle{eptcs}
\bibliography{ttc}

\clearpage

\appendix
\section{Appendix}

\subsection{Patterns}

\listingiqpl{TraceQueries.eiq}{Patterns for generating trace}

\listingiqpl{PUMQueries.eiq}{Patterns for the \pum refactoring}

\listingiqpl{CSCQueries.eiq}{Patterns for the \cscz refactoring}

\subsection{Transformations}

\listingxtend{TraceTransformation.xtend}{Trace transformation}

\listingxtend{PUMTransformation.xtend}{\pum transformation}

\listingxtend{CSCTransformation.xtend}{\cscz transformation}

\end{document}
