\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TTC 2015}

\input{ttc15-commands.tex}
\usepackage{enumitem}

\newcommand{\pum}{\ttcsf{Pull Up Method}\@\xspace}
\newcommand{\cscz}{\ttcsf{Create Superclass}\@\xspace}

% metadata
\title{Java Refactoring Case: a \viatra Solution\thanks{This work was partially supported by the MONDO (EU ICT-611125) project.}}
\author{D\'{a}niel Stein \qquad G\'{a}bor Sz\'{a}rnyas \qquad \'{A}bel Heged\"{u}s \qquad Istv\'{a}n R\'{a}th
\institute{Budapest University of Technology and Economics\\
Department of Measurement and Information Systems\\
H-1117 Magyar tud\'{o}sok krt. 2, Budapest, Hungary}
\email{daniel.stein@inf.mit.bme.hu, \{szarnyas, abel.hegedus, rath\}@mit.bme.hu}
}
\def\titlerunning{Java Refactoring Case: a VIATRA Solution}
\def\authorrunning{D. Stein et al.}

\begin{document}
\maketitle

\begin{abstract}
This paper presents a solution for the Java Refactoring Case of the 2015 Transformation Tool Contest. The solution utilises \jdt for creating the program graph; while \eiq, \viatra and the \xtend programming language are used for defining and performing the model transformations.
\end{abstract}

\section{Introduction}

This paper describes a solution for the TTC 2015 Java Refactoring Case. The source code of the solution is available as an open-source project.\footnote{\url{https://github.com/FTSRG/java-refactoring-ttc-viatra}} There is also a SHARE image available.\footnote{\url{http://is.ieis.tue.nl/staff/pvgorp/share/?page=ConfigureNewSession&vdi=.vdi}}\todo{SHARE URL}

\section{Preliminaries}

The use of automated model transformations is a key factor in modern model-driven system engineering. Model transformations allow the users to query, derive and manipulate large industrial models, including models based on existing systems, \eg source code models created with reverse engineering techniques. Since such transformations are frequently integrated to modeling environments, they need to feature both high performance and a concise programming interface to support software engineers.

\subsection{\eiq}

The objective of the \eiq~\cite{models2010, eiq-homepage} framework is to provide a declarative way to define queries over EMF models. \eiq extended the pattern language of \viatratwo with new features (including transitive closure, role navigation, match count) and tailored it to EMF models~\cite{iqpl}. While \eiq is developed with a focus on \emph{incremental query evaluation}, the latest version also provides a \emph{local search-based query evaluation} algorithm.

\subsection{\viatra}

The \viatra framework supports the development of model transformations with specific focus on event-driven, reactive transformations~\cite{viatra}. Building upon the incremental query support of \eiq, \viatra offers a language to define transformations and a reactive transformation engine to execute certain transformations upon changes in the underlying model. The \viatra project provides:

\begin{itemize}[noitemsep]
	\item An internal DSL over the \xtend~\cite{Xtend} language to specify both batch and event-driven, reactive transformations.
	\item A complex event-processing engine over EMF models to specify reactions upon detecting complex sequences of events.
	\item A rule-based design space exploration framework to explore design candidates as models satisfying multiple criteria.
	\item A model obfuscator to remove sensitive information from a confidential model (\eg to create bug reports).
\end{itemize}

The current \viatra{} project is a full rewrite of the previous \viatratwo{} framework, now with full compatibility and support for EMF models. The history of the \viatra{} family is described in~\cite{viatra-history}.

\section{Case Description}

Refactoring operations are often used in software engineering to improve the readability, maintainability of existing source code without altering the behaviour of the software. The goal of the Java Refactoring Case~\cite{ttc-refactoring-case} is to use model transformation tools to refactor Java source code. The main challenges of the case are the following:

\begin{enumerate}[noitemsep]
\item Transforming the \emph{Java source code} to a \emph{program graph} (PG).
\item Performing the refactoring transformation on the program graph.
\item Synchronising the source code and the program graph using a bidirectional transformation.
\end{enumerate}

The source code is defined in a restricted sub-language of Java 1.4. The EMF metamodel of the PG is provided in the case description. The case considers two refactoring operations:

\begin{itemize}[noitemsep]
\item \pum
\item \cscz
\end{itemize}

\section{Implementation}

The solution was developed partly in IntelliJ IDEA and partly in the Eclipse IDE. The projects are not tied to the any development environment and can be compiled with the Apache Maven~\cite{Maven} build automation tool. This offers a number of benefits, including easy portability and the possibility of continuous integration.

The code is written in Java~8 and Xtend~\cite{Xtend}. The queries and transformations were defined in \eiq and \viatra, respectively. For developing the Xtend code and editing the graph patterns, it is required to use the Eclipse IDE. For setting up the IDE, please refer to the readme file. 

\subsection{Java Development Tools}

The solution requires a technology to parse the Java code to a program graph model and serialize the refactored model to source code. While the case description mentions the JaMoPP~\cite{JaMoPP} and MoDisco~\cite{MoDisco} technologies, our solution builds on top of the Eclipse Java Development Tools (JDT)~\cite{jdt} used in the Eclipse Java IDE as we were already using JDT in other projects.

Compared to the MoDisco framework (which uses JDT internally), we found JDT to be simpler to deploy outside the Eclipse environment, \ie without defining an Eclipse workspace.

Meanwhile, the JaMoPP project has almost completely been abandoned and therefore it is only capable of parsing Java 1.5 source files. While this would not pose a problem for this case, we think it is best to use an actively developed technology such as JDT which supports the latest (1.8) version of the Java language. As JDT is frequently used to parse large source code repositories, it is carefully optimised and supports lazy loading. Unlike JaMoPP and MoDisco, JDT does not produce an EMF model.

The JDT parser generates Abstract Syntax Trees (ASTs) from the provided source code files with an optional binding resolution mechanism. This way, the separate syntax trees can be connected to an Abstract Syntax Graph (ASG).

\subsection{Workflow of the Transformation}

\ttcfig{pg}{Workflow of the transformation}{0.8}

\autoref{fig:pg} shows the workflow of the transformation. The framework receives the path to the directory containing the source files. Each source files is treated as a \emph{compilation unit} and parsed using JDT~\ttccircled{1} to ASTs. Using JDT's binding resolution mechanism, these ASTs are connected to an ASG.

As the JDT model does not support complex queries and traversal operations, the framework uses a visitor~\ttccircled{2} to perform a two-pass traversal on the ASG:

\begin{enumerate}[noitemsep]
\item For each object, the visitor creates the corresponding object(s) in the PG. The framework uses maps to store the mapping from the objects in the ASG to the objects in the PG.
\item Using the maps populated in the previous step, the visitor creates the cross-references between the objects in the PG (\eg x and y objects).
\end{enumerate}

To support efficient queries, we extended the program graph metamodel with a \emph{trace model}~(\autoref{fig:trace-mm}).  The trace model ...

The trace model is generated with a \viatra transformation (\ttccircled{3}, \ttccircled{4}).

The refactoring operations are implemented as model transformations on the JDT ASG and the PG. Each model transformation is defined in \viatra: the LHS is defined with an \eiq pattern and the RHS is defined with an imperative Xtend code. As \viatra does not support bidirectional transformations, for each transformation on the PG, we also execute the appropriate actions on the ASG to keep the two graphs in sync.

\ttcfig{trace-mm}{Metamodel of the trace model}{1}

\subsection{Transforming the ASG to Source Code}

The changes in the ASG are propagated to the source code~\ttccircled{5}. The ASG is transformed using JDT's \ttcsf{CompilationUnit.rewrite()} method which converts the changes of the abstract syntax graph to a set of text manipulation operations (\ttcsf{TextEdit} class).

\section{Evaluation}

The benchmarks were conducted on a 64-bit Ubuntu Linux machine.

%\ttcfig{benchmark-results}{Benchmark results}{0.8}

\section{Summary}

The paper presented a solution for the Java Refactoring case of the 2015 Transformation Tool Contest. The solution addresses both challenges (bidirectional synchrosiation and program refactoring) and both refactoring operations (pull up method, create superclass) defined in the case. The framework is flexible enough to allow the user to define new refactoring operations, \eg \ttcsf{Extract Class} or \ttcsf{Pull Up Field}.

\bibliographystyle{eptcs}
\bibliography{ttc}

\clearpage

\appendix
\section{Appendix}

\subsection{Patterns}

\listingiqpl{TraceQueries.eiq}{Patterns for generating trace}

\listingiqpl{PUMQueries.eiq}{Patterns for the \pum refactoring}

\listingiqpl{CSCQueries.eiq}{Patterns for the \cscz refactoring}

\subsection{Transformations}

\listingxtend{TraceTransformation.xtend}{Trace transformation}

\listingxtend{PUMTransformation.xtend}{\pum transformation}

\listingxtend{CSCTransformation.xtend}{\cscz transformation}

\end{document}
